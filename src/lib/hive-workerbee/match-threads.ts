/**
 * Match Threads â€” live game discussion threads on Hive.
 *
 * Each match gets a container post under @sportsbites (same account as daily
 * sportsbites). Users post 280-char sportsbites as replies to the match
 * container. Threads are auto-created from TheSportsDB events and remain
 * open for 24 hours after the event ends.
 */

import { SportsEvent } from '@/types/sports';
import { SPORTS_ARENA_CONFIG, MUTED_AUTHORS } from './client';
import { makeHiveApiCall } from './api';
import { createCommentOperation, generatePermlink } from './wax-helpers';
import {
  transformToSportsbite,
  Sportsbite,
  PublishSportsbiteData,
  SPORTSBITES_CONFIG,
  validateSportsbiteContent,
} from './sportsbites';

// ---------------------------------------------------------------------------
// Config
// ---------------------------------------------------------------------------

export const MATCH_THREAD_CONFIG = {
  PARENT_AUTHOR: 'sportsbites',
  CONTENT_TYPE: 'match-thread-container',
  THREAD_OPEN_HOURS: 24,
  PRE_CREATE_HOURS: 2,
  DEFAULT_TAGS: ['sportsblock', 'match-thread', 'sportsbites'],
};

// ---------------------------------------------------------------------------
// Permlink helpers
// ---------------------------------------------------------------------------

/** Deterministic permlink for a match thread: `match-thread-{eventId}` */
export function getMatchThreadPermlink(eventId: string): string {
  return `match-thread-${eventId}`;
}

// ---------------------------------------------------------------------------
// Thread status
// ---------------------------------------------------------------------------

/** Returns true if the thread is still open for posting. */
export function isThreadOpen(eventDate: string, eventStatus: SportsEvent['status']): boolean {
  if (eventStatus === 'live' || eventStatus === 'upcoming') return true;

  // For finished events, allow posting for THREAD_OPEN_HOURS after the event time
  const eventTime = new Date(eventDate).getTime();
  const now = Date.now();
  const hoursSinceEvent = (now - eventTime) / (1000 * 60 * 60);
  return hoursSinceEvent <= MATCH_THREAD_CONFIG.THREAD_OPEN_HOURS;
}

// ---------------------------------------------------------------------------
// Container post builders
// ---------------------------------------------------------------------------

export function buildMatchThreadBody(event: SportsEvent): string {
  const teams = event.teams ? `**${event.teams.home}** vs **${event.teams.away}**` : event.name;

  const lines = [
    `## Match Thread: ${teams}`,
    '',
    `${event.icon} ${event.sport}${event.league ? ` - ${event.league}` : ''}`,
    event.venue ? `Venue: ${event.venue}` : null,
    `Kickoff: ${new Date(event.date).toUTCString()}`,
    '',
    'Share your live reactions, predictions, and hot takes!',
    '',
    '---',
    `*Auto-generated by [Sportsblock](https://sportsblock.app)*`,
  ];

  return lines.filter((l) => l !== null).join('\n');
}

export function buildMatchThreadMetadata(event: SportsEvent): string {
  return JSON.stringify({
    app: `${SPORTS_ARENA_CONFIG.APP_NAME}/${SPORTS_ARENA_CONFIG.APP_VERSION}`,
    format: 'markdown',
    tags: MATCH_THREAD_CONFIG.DEFAULT_TAGS,
    community: SPORTSBITES_CONFIG.COMMUNITY_ID,
    content_type: MATCH_THREAD_CONFIG.CONTENT_TYPE,
    match_thread: {
      event_id: event.id,
      sport: event.sport,
      league: event.league,
      home_team: event.teams?.home,
      away_team: event.teams?.away,
      venue: event.venue,
      kickoff: event.date,
    },
  });
}

// ---------------------------------------------------------------------------
// Create sportsbite operation for match threads (client-side, signed via Aioha)
// ---------------------------------------------------------------------------

export function createMatchThreadSportsbiteOperation(
  data: PublishSportsbiteData & { eventId: string }
) {
  if (MUTED_AUTHORS.includes(data.author)) {
    throw new Error('This account has been muted and cannot post sportsbites.');
  }

  const validation = validateSportsbiteContent(data.body);
  if (!validation.isValid) {
    throw new Error(`Validation failed: ${validation.errors.join(', ')}`);
  }

  const permlink = generatePermlink('bite');
  const threadPermlink = getMatchThreadPermlink(data.eventId);

  let fullBody = data.body;
  if (data.images && data.images.length > 0) {
    fullBody += '\n\n' + data.images.map((img) => `![](${img})`).join('\n');
  }
  if (data.gifs && data.gifs.length > 0) {
    fullBody += '\n\n' + data.gifs.map((gif) => `![](${gif})`).join('\n');
  }

  const metadata = {
    app: `${SPORTS_ARENA_CONFIG.APP_NAME}/${SPORTS_ARENA_CONFIG.APP_VERSION}`,
    format: 'markdown',
    tags: [
      ...MATCH_THREAD_CONFIG.DEFAULT_TAGS,
      ...(data.sportCategory ? [data.sportCategory] : []),
    ],
    content_type: SPORTSBITES_CONFIG.CONTENT_TYPE,
    sport_category: data.sportCategory,
    images: data.images,
    gifs: data.gifs,
    match_thread_id: data.eventId,
  };

  return createCommentOperation({
    author: data.author,
    body: fullBody,
    parentAuthor: MATCH_THREAD_CONFIG.PARENT_AUTHOR,
    parentPermlink: threadPermlink,
    permlink,
    title: '',
    jsonMetadata: JSON.stringify(metadata),
  });
}

// ---------------------------------------------------------------------------
// Fetch match thread bites from Hive
// ---------------------------------------------------------------------------

export async function fetchMatchThreadBites(
  eventId: string,
  options: { limit?: number; before?: string } = {}
): Promise<{ sportsbites: Sportsbite[]; hasMore: boolean; nextCursor?: string }> {
  const { limit = 20, before } = options;

  try {
    const permlink = getMatchThreadPermlink(eventId);

    const replies = await makeHiveApiCall<unknown[]>('condenser_api', 'get_content_replies', [
      MATCH_THREAD_CONFIG.PARENT_AUTHOR,
      permlink,
    ]);

    if (!Array.isArray(replies)) {
      return { sportsbites: [], hasMore: false };
    }

    let bites = replies
      .map(transformToSportsbite)
      .filter((s): s is Sportsbite => s !== null)
      .filter((s) => !MUTED_AUTHORS.includes(s.author));

    // Sort newest first
    bites.sort((a, b) => new Date(b.created).getTime() - new Date(a.created).getTime());

    // Cursor pagination
    if (before) {
      const beforeIndex = bites.findIndex((s) => s.id === before);
      if (beforeIndex !== -1) {
        bites = bites.slice(beforeIndex + 1);
      }
    }

    const hasMore = bites.length > limit;
    const page = bites.slice(0, limit);
    const nextCursor = hasMore ? page[page.length - 1]?.id : undefined;

    return { sportsbites: page, hasMore, nextCursor };
  } catch (error) {
    console.error(`[fetchMatchThreadBites] Error for event ${eventId}:`, error);
    return { sportsbites: [], hasMore: false };
  }
}
