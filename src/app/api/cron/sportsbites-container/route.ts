import { NextResponse } from 'next/server';
import { verifyCronRequest, createUnauthorizedResponse } from '@/lib/api/cron-auth';
import { broadcastWithKey } from '@/lib/hive-workerbee/broadcast';
import {
  getContainerPermlink,
  formatContainerDate,
  SPORTSBITES_CONFIG,
} from '@/lib/hive-workerbee/sportsbites';
import { SPORTS_ARENA_CONFIG } from '@/lib/hive-workerbee/client';
import { makeHiveApiCall } from '@/lib/hive-workerbee/api';

export const runtime = 'nodejs';
export const dynamic = 'force-dynamic';

/**
 * Cron endpoint: creates a daily Sportsbites container post on the
 * @sportsbites Hive account. Runs at midnight UTC via Vercel Cron.
 *
 * The container is a root post in the sportsblock community.
 * Users post sportsbites as comments/replies to that day's container.
 */
export async function GET() {
  if (!(await verifyCronRequest())) {
    return NextResponse.json(createUnauthorizedResponse(), { status: 401 });
  }

  const postingKey = process.env.SPORTSBITES_POSTING_KEY;
  if (!postingKey) {
    return NextResponse.json(
      { success: false, error: 'SPORTSBITES_POSTING_KEY not configured' },
      { status: 503 }
    );
  }

  try {
    const today = new Date();
    const permlink = getContainerPermlink(today);
    const dateStr = today.toISOString().split('T')[0];

    console.log(`[Cron] Creating sportsbites container for ${dateStr}...`);

    // Idempotency check — if container already exists, skip
    const existing = await makeHiveApiCall<Record<string, unknown>>(
      'condenser_api',
      'get_content',
      [SPORTSBITES_CONFIG.PARENT_AUTHOR, permlink]
    );

    if (existing && existing.author && (existing.body as string)?.length > 0) {
      console.log(`[Cron] Container already exists for ${dateStr}`);
      return NextResponse.json({
        success: true,
        message: `Container already exists for ${dateStr}`,
        permlink,
        alreadyExists: true,
      });
    }

    // Build the container post
    const title = `Sportsbites Daily Thread - ${formatContainerDate(today)}`;
    const body = [
      `## Sportsbites Daily Thread - ${formatContainerDate(today)}`,
      '',
      'Share your quick sports takes! 280 characters of pure sports passion.',
      '',
      '---',
      `*Auto-generated by [Sportsblock](https://sportsblock.app) on ${dateStr}*`,
    ].join('\n');

    const metadata = JSON.stringify({
      app: `${SPORTS_ARENA_CONFIG.APP_NAME}/${SPORTS_ARENA_CONFIG.APP_VERSION}`,
      format: 'markdown',
      tags: ['sportsblock', 'sportsbites', SPORTSBITES_CONFIG.COMMUNITY_ID],
      community: SPORTSBITES_CONFIG.COMMUNITY_ID,
      content_type: 'sportsbites-container',
    });

    // Root post: parent_author='' posts to community
    // Include comment_options to decline payout — the container is just a
    // wrapper; only the individual sportsbite replies should earn rewards.
    const result = await broadcastWithKey(
      [
        [
          'comment',
          {
            parent_author: '',
            parent_permlink: SPORTSBITES_CONFIG.COMMUNITY_ID,
            author: SPORTSBITES_CONFIG.PARENT_AUTHOR,
            permlink,
            title,
            body,
            json_metadata: metadata,
          },
        ],
        [
          'comment_options',
          {
            author: SPORTSBITES_CONFIG.PARENT_AUTHOR,
            permlink,
            max_accepted_payout: '0.000 HBD',
            percent_hbd: 10000,
            allow_votes: true,
            allow_curation_rewards: true,
            extensions: [],
          },
        ],
      ],
      postingKey
    );

    if (!result.success) {
      throw new Error(result.error || 'Broadcast failed');
    }

    console.log(`[Cron] Container created for ${dateStr}: tx=${result.transactionId}`);

    return NextResponse.json({
      success: true,
      message: `Container created for ${dateStr}`,
      permlink,
      transactionId: result.transactionId,
      blockNum: result.blockNum,
    });
  } catch (error) {
    console.error('[Cron] Sportsbites container creation failed:', error);
    return NextResponse.json(
      {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
      },
      { status: 500 }
    );
  }
}
